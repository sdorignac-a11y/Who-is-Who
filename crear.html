<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Impostor FÃºtbol â€“ Lobby</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --panel:#0f2b4b;--panel-2:#0c213a;--yellow:#f6c11b;--yellow-2:#f39c12;--text:#eaf2ff;--muted:#a7c0e8;
    --space:16px; /* espacio base adaptable */
  }
  *{box-sizing:border-box}

  /* ====== BASE ====== */
  html,body{height:100%;margin:0}
  body{
    font-family:"Outfit",system-ui;
    color:var(--text);
    background:url("fondo-cancha.png") center/cover no-repeat fixed;
    /* Altura real en mÃ³viles y safe-areas */
    min-height:100dvh;
    padding:
      calc(env(safe-area-inset-top,0px) + 8px)
      calc(env(safe-area-inset-right,0px) + 8px)
      calc(env(safe-area-inset-bottom,0px) + 8px)
      calc(env(safe-area-inset-left,0px) + 8px);
    overflow:auto; /* Permite scroll en vertical */
  }

  .container{
    width:min(1200px,96vw);
    margin:0 auto;
    padding:20px 0 28px;
    display:flex;flex-direction:column;gap:18px;
    min-height:calc(100dvh - 16px - 16px);
  }

  /* ====== ROOM CARD ====== */
  .room-card{
    background:linear-gradient(180deg,rgba(7,28,56,.9),rgba(8,33,63,.88));
    border:1.5px solid rgba(128,180,255,.25);
    border-radius:16px; box-shadow:0 10px 28px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.04);
    padding:16px 18px;
    display:grid;
    grid-template-columns:auto 1fr auto;
    align-items:center; gap:16px;
  }
  .brand{display:flex;align-items:center;gap:10px}
  .brand .ball{width:44px;height:44px;border-radius:50%;background:radial-gradient(circle,#fff 0 48%,transparent 50%),conic-gradient(#111 0 60deg,#fff 0 120deg,#111 0 180deg,#fff 0 240deg,#111 0 300deg,#fff 0 360deg);box-shadow:0 0 14px rgba(255,255,255,.35)}
  .brand h1{margin:0;letter-spacing:.5px;line-height:1;font-size:clamp(20px,4.8vw,28px);font-weight:800;text-transform:uppercase;text-shadow:0 3px 0 rgba(0,0,0,.5)}
  .brand h1 span{color:#7cf062}

  .code-box{
    background:linear-gradient(180deg,#0c2747,#0a213b);
    border:1px solid rgba(128,180,255,.28); border-radius:12px;
    padding:10px 12px;
    display:flex;gap:10px;align-items:center;justify-content:center;flex-wrap:wrap;
  }
  .room-code{font-size:clamp(22px,7vw,36px);font-weight:800;letter-spacing:2px}
  .btn{
    background:linear-gradient(180deg,#1e68d6,#184fa5);
    border:1px solid rgba(110,178,255,.65);
    color:#eaf2ff;font-weight:700;
    padding:10px 14px;border-radius:12px;
    box-shadow:0 6px 14px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.08);
    cursor:pointer;
    font-size:clamp(12px,3.6vw,14px);
    touch-action:manipulation;
  }

  .user-area{display:flex;flex-direction:column;gap:10px;align-items:flex-end}
  .userbox{
    display:flex;align-items:center;gap:8px;
    background:linear-gradient(180deg,#0c2747,#0a213b);
    border:1px solid rgba(128,180,255,.28);border-radius:12px;
    padding:8px 10px;font-weight:700;color:#cfe4ff
  }
  .mini-btn{padding:6px 10px;border-radius:10px;cursor:pointer;background:linear-gradient(180deg,#1e68d6,#184fa5);border:1px solid rgba(110,178,255,.65);color:#eaf2ff;font-weight:700}
  .me-badge{color:#ffd166;font-weight:900;margin-left:4px}
  .me-outline{outline:2px solid #f6c11b;outline-offset:2px;border-radius:16px}

  /* ====== PLAYERS GRID (auto-fit) ====== */
  .players{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(110px, 1fr));
    gap:12px;
    padding:0 4px;
  }
  .player{
    background:linear-gradient(180deg,rgba(14,39,70,.9),rgba(10,30,53,.85));
    border:1px solid rgba(128,180,255,.25);border-radius:16px;
    padding:10px 8px;display:flex;flex-direction:column;align-items:center;gap:8px;min-height:108px
  }
  .avatar{width:56px;height:56px;border-radius:50%;background:radial-gradient(36px 24px at 50% 30%,#ffd6b4 0 60%,#e9b089 61% 100%),radial-gradient(80px 40px at 50% 105%,#222 0 60%,transparent 61%),linear-gradient(180deg,#e23a3a,#a61e1e);display:grid;place-items:center;overflow:hidden}
  .avatar.placeholder{background:radial-gradient(28px 28px at 50% 40%,#2f4b73 0 60%,#203a5e 61% 100%),radial-gradient(48px 48px at 50% 110%,#162b4a 0 58%,transparent 59%)}
  .avatar-img{width:100%;height:100%;object-fit:cover;display:block}
  .player small{color:var(--muted);font-weight:600;font-size:clamp(11px,3.2vw,12px)}

  /* ====== SETTINGS GRID (auto-fit) ====== */
  .settings{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(180px, 1fr));
    gap:12px;
  }
  .card{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid rgba(128,180,255,.25);border-radius:16px;padding:14px}
  .card h3{margin:0 0 8px;font-size:clamp(14px,3.8vw,16px);letter-spacing:.3px;color:#cce0ff;text-transform:uppercase;font-weight:800}
  .selector{display:flex;align-items:center;justify-content:space-between;gap:8px;background:linear-gradient(180deg,#0b2441,#0a213b);border:1px solid rgba(128,180,255,.28);border-radius:12px;padding:10px}
  .selector .value{font-size:clamp(20px,6.5vw,28px);font-weight:800}
  .selector .arrow{width:40px;height:40px;border-radius:10px;background:linear-gradient(180deg,#1e68d6,#184fa5);border:1px solid rgba(110,178,255,.7);display:grid;place-items:center;cursor:pointer;font-size:20px;font-weight:900}

  /* ====== CTA ====== */
  .cta{display:flex;justify-content:center;flex-wrap:wrap;gap:12px}
  .btn-cta{
    background:linear-gradient(180deg,var(--yellow),var(--yellow-2));
    border:1px solid rgba(255,210,80,.9);
    color:#10223b;font-weight:900;
    font-size:clamp(18px,6.5vw,28px);
    padding:14px 24px;border-radius:16px
  }

  /* ====== Overlay rol ====== */
  #reveal{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,10,20,.9);z-index:1000;padding:16px}
  .rev-card{width:min(680px,96vw);background:linear-gradient(180deg,#0d2747,#0b203a);border:1px solid rgba(128,180,255,.3);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:20px;text-align:center}
  .rev-content{padding:16px;background:linear-gradient(180deg,#102c4f,#0c2441);border:1px solid rgba(128,180,255,.25);border-radius:16px;min-height:100px;display:grid;place-items:center;font-size:clamp(18px,5.8vw,26px);font-weight:800}
  .rev-avatar{width:80px;height:80px;border-radius:50%;overflow:hidden;border:2px solid rgba(255,255,255,.35);margin:0 auto 10px;background:#0b203a;display:grid;place-items:center}
  .rev-name{font-weight:800;margin-top:4px;opacity:.9}
  .tip{background:#08213a;border:1px solid rgba(128,180,255,.25);padding:8px 12px;border-radius:12px;margin:10px;opacity:.9}

  /* ====== Sorteo ====== */
  #drawOverlay{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,12,24,.9);z-index:1200;padding:16px}
  .draw-card{width:min(760px,96vw);background:linear-gradient(180deg,#0d2747,#0b203a);border:1px solid rgba(128,180,255,.3);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:16px}
  .draw-title{margin:0 0 10px;text-align:center}
  .bowl{position:relative;height:220px;border-radius:16px;background:radial-gradient(circle at 50% 0%, rgba(255,255,255,.09), transparent 60%), linear-gradient(180deg,#0a2340,#0a1f37);border:1px solid rgba(128,180,255,.25);overflow:hidden;display:flex;align-items:flex-end;justify-content:center;padding-bottom:16px}
  .ball{position:absolute;bottom:-40px;width:26px;height:26px;border-radius:50%;background:radial-gradient(circle at 30% 30%,#fff,#cfe1ff 55%,#82a8ff);opacity:.7;animation:float 3s ease-in-out infinite}
  .ball:nth-child(2){left:20%;animation-delay:.2s}.ball:nth-child(3){left:40%;animation-delay:.4s}.ball:nth-child(4){left:60%;animation-delay:.6s}.ball:nth-child(5){left:80%;animation-delay:.8s}
  @keyframes float{0%,100%{transform:translateY(0)}50%{transform:translateY(-18px)}}
  .slip{position:absolute;bottom:12px;left:50%;transform:translateX(-50%) translateY(120%);background:#fff;color:#0c2441;border-radius:8px;padding:8px 12px;font-weight:900;box-shadow:0 6px 18px rgba(0,0,0,.45);opacity:0;white-space:nowrap}
  .slip.reveal{animation:popUp .6s ease-out forwards}
  @keyframes popUp{0%{transform:translateX(-50%) translateY(120%) rotate(-6deg);opacity:0}
                   60%{transform:translateX(-50%) translateY(-26%) rotate(1deg);opacity:1}
                   100%{transform:translateX(-50%) translateY(-10%) rotate(0);opacity:1}}
  .order-list{margin:12px 4px 0;display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .order-item{background:linear-gradient(180deg,#0c2747,#0a213b);border:1px solid rgba(128,180,255,.28);border-radius:10px;padding:8px 10px;display:flex;align-items:center;gap:8px}
  .order-badge{width:26px;height:26px;border-radius:8px;background:linear-gradient(180deg,#1e68d6,#184fa5);border:1px solid rgba(110,178,255,.7);display:grid;place-items:center;font-weight:900}
  .order-name{font-weight:800}

  /* ====== Cartel de turno ====== */
  #turnBanner{
    position:absolute; top:38%; left:50%; transform:translate(-50%,-50%) scale(.92);
    display:none; padding:12px 18px; border-radius:16px;
    background:linear-gradient(135deg,#1e68d6,#4ade80);
    color:#fff; font-weight:900; font-size:clamp(16px,5.5vw,26px); letter-spacing:.3px;
    text-shadow:0 2px 10px rgba(0,0,0,.35);
    box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.15);
    border:1px solid rgba(255,255,255,.2);
    pointer-events:none; z-index:5; opacity:0;
    transition:transform .35s ease, opacity .35s ease;
  }
  #turnBanner.show{display:block;opacity:1;transform:translate(-50%,-50%) scale(1);}
  #turnBanner.hide{opacity:0;transform:translate(-50%,-50%) scale(.92);}
  #turnBanner .who{font-size:clamp(18px,6vw,30px);text-transform:uppercase;}

  /* ====== Chat (fase debate) ====== */
  #chatList{ padding:14px; }
  .chat-row{ display:flex; margin:8px 0; }
  .chat-row.mine{ justify-content:flex-end; }
  .chat-row.other{ justify-content:flex-start; }
  .bubble{
    max-width:80%;
    padding:10px 14px; border-radius:16px;
    background:#142946; border:1px solid rgba(128,180,255,.18);
    color:#cfe4ff; box-shadow:0 4px 12px rgba(0,0,0,.25);
    animation:fadeUp .25s ease;
    font-size:clamp(13px,4vw,16px);
  }
  .chat-row.mine .bubble{
    background:linear-gradient(135deg,#22c55e,#16a34a);
    color:#fff; border-color:rgba(255,255,255,.2);
  }
  .bubble .name{ font-weight:800; opacity:.9; margin-bottom:2px; font-size:clamp(11px,3.2vw,13px); }
  .bubble .text{ font-size:inherit }
  @keyframes fadeUp{from{opacity:0; transform:translateY(4px)} to{opacity:1; transform:translateY(0)}}

  /* ====== RESPONSIVE LAYOUT ====== */
  @media (max-width: 900px){
    /* Fondo fijo puede jankear en iOS; cÃ¡mbialo en mÃ³viles */
    body{ background-attachment:scroll; }
    .room-card{
      grid-template-columns:1fr;
      grid-auto-rows:auto;
      gap:12px;
      text-align:center;
    }
    .user-area{align-items:center}
  }

  @media (max-width: 420px){
    .selector .arrow{width:36px;height:36px}
    .avatar{width:52px;height:52px}
    .order-list{grid-template-columns:1fr} /* lista a una columna */
  }
</style>
</head>
<body>
  <div class="container">
    <div class="room-card">
      <div class="brand"><div class="ball"></div><h1>Impostor <span>FÃºtbol</span></h1></div>
      <div class="code-box"><strong style="opacity:.7">CÃ“DIGO:</strong><div class="room-code" id="roomCode">â€”</div><button id="copyBtn" class="btn">Copiar</button></div>
      <div class="user-area">
        <div class="userbox">ðŸ‘¤ <span id="meName">â€”</span> <button id="editName" class="mini-btn">Editar</button></div>
        <button id="shareBtn" class="btn">Compartir enlace</button>
      </div>
    </div>

    <div class="players" id="players"></div>

    <div class="settings">
      <div class="card"><h3>Impostores</h3><div class="selector"><div class="arrow" data-dec="impostores">â€¹</div><div class="value" id="impostoresVal">1</div><div class="arrow" data-inc="impostores">â€º</div></div></div>
      <div class="card"><h3>Jugadores</h3><div class="selector"><div class="arrow" data-dec="jugadores">â€¹</div><div class="value" id="jugadoresVal">8</div><div class="arrow" data-inc="jugadores">â€º</div></div></div>
      <div class="card"><h3>Tema</h3><div class="selector"><div class="arrow" data-dec="tema">â€¹</div><div class="value" id="temaVal">Clubes</div><div class="arrow" data-inc="tema">â€º</div></div></div>
      <div class="card"><h3>Tiempo</h3><div class="selector"><div class="arrow" data-dec="tiempo">â€¹</div><div class="value" id="tiempoVal">60s</div><div class="arrow" data-inc="tiempo">â€º</div></div></div>
    </div>

    <div class="cta">
      <button id="startBtn" class="btn-cta">EMPEZAR PARTIDA</button>
      <button id="leaveBtn" class="btn" style="display:none">ABANDONAR PARTIDA</button>
      <button id="deleteRoomBtn" class="btn" style="display:none;background:linear-gradient(180deg,#ea4335,#c92e21);border-color:#ffb3ac">ELIMINAR SALA</button>
    </div>
  </div>

  <!-- Overlay: rol + countdown -->
  <div id="reveal">
    <div class="rev-card">
      <h2 style="margin:0 0 10px;font-size:clamp(18px,6vw,24px)">Tu rol</h2>
      <div id="revContent" class="rev-content"></div>
      <div id="countdown" style="margin-top:12px;font-size:clamp(16px,5.3vw,22px);font-weight:700;color:#f6c11b">Pasando en 10s...</div>
    </div>
  </div>

  <!-- Overlay: Sorteo del orden -->
  <div id="drawOverlay">
    <div class="draw-card">
      <h2 class="draw-title" style="font-size:clamp(18px,6vw,24px)">Sorteo del orden</h2>
      <div class="bowl" id="bowl">
        <div class="ball"></div><div class="ball"></div><div class="ball"></div><div class="ball"></div><div class="ball"></div>
        <div class="slip" id="slip">â€”</div>
      </div>
      <div id="orderList" class="order-list"></div>
    </div>
  </div>

  <!-- Overlay: Resultados (expulsado / empate) -->
<div id="resultsOverlay" style="display:none;position:fixed;inset:0;z-index:1400;place-items:center;background:rgba(0,10,20,.9);padding:16px">
  <div class="rev-card" style="width:min(680px,96vw)">
    <h2 style="margin:0 0 10px;font-size:clamp(18px,6vw,24px)">Resultados</h2>
    <div id="resultsBox" class="rev-content"></div>
    <div class="tip" id="resultsSub" style="margin-top:10px;opacity:.9"></div>
  </div>
</div>


  <!-- FASE: DEBATE (chat) -->
  <div id="phaseDiscuss" style="display:none;position:fixed;inset:0;background:rgba(0,10,20,.9);padding:clamp(12px,2.5vw,24px)">
    <div style="max-width:min(900px,96vw);margin:0 auto;background:#0b203a;border:1px solid rgba(128,180,255,.3);border-radius:18px;height:calc(100dvh - 2*clamp(12px,2.5vw,24px) - env(safe-area-inset-top,0px) - env(safe-area-inset-bottom,0px));display:flex;flex-direction:column;position:relative">
      <div id="turnBanner">âš½ Va <span id="turnName" class="who">â€”</span></div>

      <div style="padding:14px 16px;border-bottom:1px solid rgba(128,180,255,.15);display:flex;justify-content:space-between;align-items:center">
        <h2 style="margin:0;font-size:clamp(18px,6vw,22px)">Debate</h2>
        <div style="display:flex;flex-direction:column;align-items:flex-end;gap:4px;font-size:clamp(11px,3.5vw,13px)">
          <small id="timer" style="opacity:.9;font-weight:800"></small>
          <small id="turnHint" style="opacity:.85"></small>
          <small id="cooldownHint" style="opacity:.7"></small>
        </div>
      </div>
      <div id="firstWordTip" class="tip" style="display:none">Primero, cada jugador debe enviar <strong>UNA</strong> palabra (2â€“24 letras). DespuÃ©s, chat libre.</div>
      <div id="chatList" style="flex:1;overflow:auto;-webkit-overflow-scrolling:touch"></div>
      <form id="chatForm" style="padding:12px;display:flex;gap:10px;border-top:1px solid rgba(128,180,255,.15)">
        <input id="chatInput" maxlength="140" placeholder="Primero UNA palabra (2â€“24 letras)â€¦"
               style="flex:1;padding:12px;border-radius:12px;border:1px solid rgba(128,180,255,.35);background:#0a213b;color:#eaf2ff;font-size:clamp(14px,4.2vw,16px)">
        <button class="btn" type="submit">Enviar</button>
      </form>
      <div id="voteBar" style="padding:10px 12px;border-top:1px solid rgba(128,180,255,.15);display:flex;gap:10px;flex-wrap:wrap"></div>
    </div>
  </div>

  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
  import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection, getDocs, writeBatch, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAegeue7A8qFFW4IScFFgtvT4P1g2GLkCM",
    authDomain: "who-is-who-6ea99.firebaseapp.com",
    projectId: "who-is-who-6ea99",
    storageBucket: "who-is-who-6ea99.firebasestorage.app",
    messagingSenderId: "718537140049",
    appId: "1:718537140049:web:7400ec7e5467b387f8d570",
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  await setPersistence(auth, browserLocalPersistence);
  async function ensureAuth(){
    const u = await new Promise(r=>{ const un = onAuthStateChanged(auth,(x)=>{un(); r(x);}); });
    return u || (await signInAnonymously(auth)).user;
  }
  await ensureAuth();

  const AVATAR_MAP = { a1:"avatars/a1.png",a2:"avatars/a2.png",a3:"avatars/a3.png",a4:"avatars/a4.png",a5:"avatars/a5.png",a6:"avatars/a6.png",a7:"avatars/a7.png",a8:"avatars/a8.png",a9:"avatars/a9.png",a10:"avatars/a10.png",a11:"avatars/a11.png",a12:"avatars/a12.png" };

  const $ = s => document.querySelector(s);
  const roomCodeEl  = $("#roomCode");
  const meNameEl    = $("#meName");
  const playersWrap = $("#players");
  const leaveBtn = document.getElementById("leaveBtn");
  const deleteRoomBtn = document.getElementById("deleteRoomBtn"); // NUEVO

  function getStoredName(){
    const qp = new URLSearchParams(location.search);
    const qName = qp.get("name");
    if (qName && qName.trim()) localStorage.setItem("displayName", qName.trim());
    const s = localStorage.getItem("displayName") || "";
    return (s.trim().length>=2 && s.trim().length<=16) ? s.trim() : "Jugador";
  }
  function getStoredAvatar(){
    const qp = new URLSearchParams(location.search);
    const qAvatar = qp.get("avatar");
    const AV = { a1:1,a2:1,a3:1,a4:1,a5:1,a6:1,a7:1,a8:1,a9:1,a10:1,a11:1,a12:1 };
    if (qAvatar && AV[qAvatar]) localStorage.setItem("avatarKey", qAvatar);
    const k = localStorage.getItem("avatarKey") || "";
    return AVATAR_MAP[k] ? k : "";
  }

  async function editAndSaveName(playerRef){
    const prev = getStoredName();
    const nuevo = prompt("Tu nombre para mostrar (2â€“16 chars):", prev) ?? "";
    const v = nuevo.trim();
    if (v.length<2 || v.length>16) return;
    localStorage.setItem("displayName", v);
    meNameEl.textContent = v;
    try{ if(playerRef) await updateDoc(playerRef, { name: v }); }catch{}
  }

  function genCode(len=6){const A="ABCDEFGHJKLMNPQRSTUVWXYZ23456789";let s="";for(let i=0;i<len;i++) s+=A[Math.floor(Math.random()*A.length)];return s;}
  async function createUniqueRoomCode(db,tries=10){
    for(let i=0;i<tries;i++){const c=genCode(6);const ref=doc(db,"rooms",c);if(!(await getDoc(ref)).exists()) return c;}
    return genCode(8);
  }

  let lastPlayers=[];
  function drawPlayers(maxCount,list){
    const ordered=(list||[]).slice().sort((a,b)=>(a.slot||0)-(b.slot||0));
    playersWrap.innerHTML="";
    for(let i=0;i<maxCount;i++){
      const p=ordered[i];
      const card=document.createElement("div"); card.className="player";
      const av=document.createElement("div"); const label=document.createElement("small");
      if(p){
        if(p.avatarKey && AVATAR_MAP[p.avatarKey]){
          av.className="avatar";
          const img=document.createElement("img"); img.className="avatar-img"; img.src=AVATAR_MAP[p.avatarKey]; img.alt=p.name||"avatar"; av.appendChild(img);
        }else{ av.className="avatar placeholder"; }
        if(p.uid===(auth.currentUser&&auth.currentUser.uid)){
          card.classList.add("me-outline"); label.innerHTML=`${p.name||`Jugador ${i+1}`} <span class="me-badge">(yo)</span>`;
        }else{ label.textContent=p.name||`Jugador ${i+1}`; }
      }else{ av.className="avatar placeholder"; label.textContent=`Jugador ${i+1}`; }
      card.append(av,label); playersWrap.append(card);
    }
  }

  const impostoresEl = document.getElementById("impostoresVal");
  const jugadoresEl  = document.getElementById("jugadoresVal");
  const temaEl       = document.getElementById("temaVal");
  const tiempoEl     = document.getElementById("tiempoVal");

  // Estado
  const state={ 
    code:"",
    impostores:1, 
    jugadores:8, 
    temas:["Clubes","Jugadores","Mundiales"], 
    temaIndex:0,
    tiempos:[30,45,60,90,120],
    tiempoIndex:2 // 60s
  };

  function render(){
    roomCodeEl.textContent = state.code || "â€”";
    impostoresEl.textContent = state.impostores;
    jugadoresEl.textContent  = state.jugadores;
    temaEl.textContent       = state.temas[state.temaIndex];
    tiempoEl.textContent     = state.tiempos[state.tiempoIndex] + "s";
    drawPlayers(state.jugadores, lastPlayers);
  }

  // Reusar sala
  const lsKey="lastRoomCode"; let isHost=false;
  function putCodeInUrl(code){ try{ history.replaceState(null,"",`?code=${code}`);}catch{} }
  let urlCode=new URLSearchParams(location.search).get("code");
  if(urlCode && urlCode.trim()){ state.code=urlCode.trim().toUpperCase(); isHost=false; }
  else{
    const prev=localStorage.getItem(lsKey);
    if(prev){
      const prevSnap=await getDoc(doc(db,"rooms",prev));
      if(prevSnap.exists()){ state.code=prev; isHost=(prevSnap.data().hostUid===(auth.currentUser&&auth.currentUser.uid)); putCodeInUrl(state.code); }
    }
    if(!state.code){ state.code=await createUniqueRoomCode(db); isHost=true; localStorage.setItem(lsKey,state.code); putCodeInUrl(state.code); }
  }
  render();

  const roomRef = doc(db,"rooms",state.code);

  const firstSnap = await getDoc(roomRef);
  if(!firstSnap.exists() && isHost){
    await setDoc(roomRef,{ hostUid:auth.currentUser.uid, status:"lobby", createdAt:Date.now(), settings:{maxPlayers:state.jugadores,impostors:state.impostores,tema:state.temas[state.temaIndex], timeSec: state.tiempos[state.tiempoIndex]} },{merge:true});
  }
  if(firstSnap.exists()) isHost = firstSnap.data().hostUid === auth.currentUser.uid;
  if(isHost){ localStorage.setItem(lsKey,state.code); putCodeInUrl(state.code); }

  const myName=getStoredName(); const myAvatar=getStoredAvatar();
  meNameEl.textContent=myName;
  await setDoc(doc(db,"rooms",state.code,"players",auth.currentUser.uid),{ uid:auth.currentUser.uid, name:myName, avatarKey:myAvatar||null, slot:isHost?1:Date.now(), online:true },{merge:true});
  const playerRef = doc(db,"rooms",state.code,"players",auth.currentUser.uid);
  document.getElementById("editName")?.addEventListener("click", ()=> editAndSaveName(playerRef));

  function setArrowsEnabled(en){ document.querySelectorAll(".arrow").forEach(b=>{ b.style.pointerEvents=en?"auto":"none"; b.style.opacity=en?"1":".55"; }); }
  setArrowsEnabled(isHost);

  // NUEVO: mostrar/ocultar botones de host (abandonar / eliminar)
  function setHostControlsVisible(on){
    leaveBtn.style.display = on ? "inline-block" : "none";
    deleteRoomBtn.style.display = on ? "inline-block" : "none";
  }
  setHostControlsVisible(isHost);

  document.querySelectorAll(".arrow").forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      const inc=btn.dataset.inc, dec=btn.dataset.dec;
      if(inc==="impostores") state.impostores=Math.min(3,state.impostores+1);
      if(dec==="impostores") state.impostores=Math.max(1,state.impostores-1);
      if(inc==="jugadores") state.jugadores=Math.min(10,state.jugadores+1);
      if(dec==="jugadores") state.jugadores=Math.max(4,state.jugadores-1);
      if(inc==="tema") state.temaIndex=(state.temaIndex+1)%state.temas.length;
      if(dec==="tema") state.temaIndex=(state.temaIndex-1+state.temas.length)%state.temas.length;
      if(inc==="tiempo") state.tiempoIndex = (state.tiempoIndex+1) % state.tiempos.length;
      if(dec==="tiempo") state.tiempoIndex = (state.tiempoIndex-1+state.tiempos.length) % state.tiempos.length;

      if(state.impostores>=state.jugadores) state.impostores=Math.max(1,state.jugadores-1);
      state.jugadores=Math.max(state.jugadores,lastPlayers.length);
      render();

      if(isHost){ 
        await setDoc(roomRef,{ 
          settings:{
            maxPlayers:state.jugadores,
            impostors: state.impostores,
            tema:      state.temas[state.temaIndex],
            timeSec:   state.tiempos[state.tiempoIndex]
          } 
        },{merge:true}); 
      }
    });
  });

  let roomSettings = null; // cache de settings para fallback
  onSnapshot(roomRef,s=>{
    if(!s.exists()) return;
    const data=s.data();
    roomSettings = data.settings || roomSettings;
    const before=isHost; isHost=(data.hostUid===auth.currentUser.uid);
    if(before!==isHost) setArrowsEnabled(isHost);
    if(before!==isHost) setHostControlsVisible(isHost); // NUEVO

    const st=data.settings||{};
    state.jugadores=st.maxPlayers??state.jugadores;
    state.impostores=st.impostors??state.impostores;
    if(st.tema){ const idx=state.temas.indexOf(st.tema); state.temaIndex = idx>=0?idx:0; }
    if(st.timeSec){ const tidx = state.tiempos.indexOf(st.timeSec); state.tiempoIndex = tidx>=0 ? tidx : state.tiempoIndex; }
    render();
  });

  onSnapshot(collection(db,"rooms",state.code,"players"), snap=>{ lastPlayers=snap.docs.map(d=>d.data()); drawPlayers(state.jugadores,lastPlayers); });

  const POOLS={ 
    Clubes:["Real Madrid","Barcelona","Boca Juniors","River Plate","PSG","Manchester City","Inter","AC Milan","Liverpool","Chelsea"], 
    Jugadores:["Lionel Messi","Cristiano Ronaldo","Diego Maradona","PelÃ©","Kylian MbappÃ©","Erling Haaland","Neymar","Zinedine Zidane","Ronaldinho","Ronaldo NazÃ¡rio"], 
    Mundiales:["Mundial 2002","Mundial 2006","Mundial 2010","Mundial 2014","Mundial 2018","Mundial 2022"] 
  };

  function pickWord(tema){ const pool=POOLS[tema]||["BalÃ³n"]; return pool[Math.floor(Math.random()*pool.length)]; }
  function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

  // START
  let starting=false;
  document.getElementById("startBtn").addEventListener("click", async ()=>{
    if(!isHost){ alert("Solo el host puede iniciar"); return; }
    if(starting) return; starting=true;
    try{
      const roomSnap=await getDoc(roomRef);
      if(!roomSnap.exists()){ alert("Sala no encontrada."); starting=false; return; }
      const room=roomSnap.data(); const st=room.settings||{};
      if(room.status==="playing"){ alert("La partida ya estÃ¡ en curso."); starting=false; return; }
      const ps=await getDocs(collection(db,"rooms",state.code,"players"));
      const players=ps.docs.map(d=>({id:d.id,...d.data()})).filter(p=>p.id&&p.online!==false);
      const K=st.impostors||1; const tema=st.tema||"Clubes";
      const timeSec = st.timeSec || state.tiempos[state.tiempoIndex];
      if(players.length<3){ alert("Se necesitan al menos 3 jugadores."); starting=false; return; }
      if(K>=players.length){ alert("Impostores debe ser menor que jugadores."); starting=false; return; }
      const palabra=pickWord(tema);
      const order=shuffleInPlace(players.map(p=>p.id));
      const impostorIds=new Set(order.slice(0,K));
      const nextRound=(room.round||0)+1;
      const batch=writeBatch(db);
      batch.update(roomRef,{status:"playing",round:nextRound,startedAt:serverTimestamp(), settings:{...st, timeSec}}); // asegura timeSec
      players.forEach(p=>{
        const aRef=doc(db,"rooms",state.code,"assignments",p.id);
        batch.set(aRef,{round:nextRound,uid:p.id,name:p.name||"Jugador",avatarKey:p.avatarKey||null,role:impostorIds.has(p.id)?"IMPOSTOR":"CIVIL",word:impostorIds.has(p.id)?null:palabra,tema,alive:true,vote:null,revealedAt:null});
      });
      const roundRef=doc(db,"rooms",state.code,"rounds",String(nextRound));
      batch.set(roundRef,{status:"reveal",createdAt:serverTimestamp(),order,turnIndex:0, timeSec}); // guarda timeSec en la ronda
      await batch.commit();
      setTimeout(async()=>{ try{ await updateDoc(roundRef,{status:"draw",drawStartedAt:serverTimestamp()}); }catch{} },10000);
    }catch(e){ console.error(e); alert(e.message||"No pude iniciar la partida."); } finally{ starting=false; }
  });

  // ABANDONAR (solo host)
  leaveBtn.addEventListener("click", async ()=>{
    if (!isHost){
      alert("Solo el host puede abandonar y resetear la sala.");
      return;
    }
    if (!confirm("Â¿Seguro que querÃ©s abandonar la partida actual? Esto limpia la ronda.")) return;

    try {
      const batchDel = writeBatch(db);
      const assignsSnap = await getDocs(collection(db,"rooms",state.code,"assignments"));
      assignsSnap.forEach(d => batchDel.delete(d.ref));
      const roundsSnap = await getDocs(collection(db,"rooms",state.code,"rounds"));
      roundsSnap.forEach(d => batchDel.delete(d.ref));
      await batchDel.commit();

      await updateDoc(doc(db,"rooms",state.code), {
        status: "lobby",
        round: 0,
        startedAt: null
      });

      document.getElementById("phaseDiscuss").style.display = "none";
      alert("SesiÃ³n abandonada. Ya podÃ©s iniciar otra partida.");

    } catch(e){
      console.error(e);
      alert("Error al abandonar: " + (e?.message || e));
    }
  });

  // ===== NUEVO: eliminar sala completa y crear otra =====
  async function deleteCollection(collRef){
    const snap = await getDocs(collRef);
    const batchLimit = 400;
    let i = 0, batch = writeBatch(db);
    for (const d of snap.docs){
      batch.delete(d.ref);
      i++;
      if(i % batchLimit === 0){ await batch.commit(); batch = writeBatch(db); }
    }
    if(i % batchLimit !== 0) await batch.commit();
  }

  async function deleteRoomDeep(){
    if(!isHost){ alert("Solo el host puede eliminar la sala."); return; }

    const ok = confirm("âš ï¸ Esto eliminarÃ¡ la SALA completa (jugadores, rondas, chat, votos). Â¿Continuar?");
    if(!ok) return;

    try{
      // 1) assignments
      await deleteCollection(collection(db,"rooms",state.code,"assignments"));

      // 2) rounds + subcolecciones
      const roundsSnap = await getDocs(collection(db,"rooms",state.code,"rounds"));
      for(const rdoc of roundsSnap.docs){
        const rid = rdoc.id;
        await deleteCollection(collection(db,"rooms",state.code,"rounds",rid,"chat"));
        await deleteCollection(collection(db,"rooms",state.code,"rounds",rid,"firstWords"));
        await deleteCollection(collection(db,"rooms",state.code,"rounds",rid,"votes"));
        await deleteDoc(rdoc.ref);
      }

      // 3) players
      await deleteCollection(collection(db,"rooms",state.code,"players"));

      // 4) doc de la sala
      await deleteDoc(doc(db,"rooms",state.code));

      localStorage.removeItem("lastRoomCode");
      location.replace("/index.html"); // ajustÃ¡ la ruta segÃºn tu hosting

    }catch(e){
      console.error(e);
      alert("Error al eliminar la sala: " + (e?.message || e));
    }
  }

  deleteRoomBtn.addEventListener("click", deleteRoomDeep); // NUEVO

  // Overlay rol
  onSnapshot(doc(db,"rooms",state.code,"assignments",auth.currentUser.uid), s=>{
    if(!s.exists()) return;
    const a=s.data(); const overlay=document.getElementById("reveal"); const box=document.getElementById("revContent");
    let avatarHtml=""; if(a.avatarKey && AVATAR_MAP[a.avatarKey]) avatarHtml=`<div class="rev-avatar"><img src="${AVATAR_MAP[a.avatarKey]}" alt="${a.name||'avatar'}"></div>`;
    const nameHtml=`<div class="rev-name">${a.name||"Jugador"}</div>`;
    overlay.style.display="grid";
    if(a.role==="IMPOSTOR"){ box.innerHTML=`${avatarHtml}${nameHtml}<div style="font-size:clamp(24px,7vw,38px);font-weight:900;color:#ff6b6b;margin:6px 0 8px">IMPOSTOR</div><div style="opacity:.85">Tu objetivo es camuflarte. No conocÃ©s la palabra.</div>`; }
    else{ box.innerHTML=`${avatarHtml}${nameHtml}<div style="opacity:.75;font-size:clamp(12px,3.8vw,14px);margin:6px 0">Palabra secreta (${a.tema})</div><div style="font-size:clamp(22px,7vw,34px);font-weight:900;color:#7cf062">${a.word}</div>`; }
    let secs=10; const countdownEl=document.getElementById("countdown");
    countdownEl.textContent=`Pasando en ${secs}s...`; const interval=setInterval(()=>{ secs--; countdownEl.textContent=`Pasando en ${secs}s...`; if(secs<=0){ clearInterval(interval); overlay.style.display="none"; } },1000);
  });

  // Utils
  function sanitize(str){ return (str||"").replace(/[<>&]/g, s=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[s])); }
  async function nameOf(uid){ try{ const snap=await getDoc(doc(db,"rooms",state.code,"players",uid)); return (snap.exists()&&(snap.data().name||"Jugador"))||"Jugador"; }catch{ return "Jugador"; } }
  const timerEl = document.getElementById("timer");
  function toMillis(ts){ return ts?.toMillis?.() ?? (ts?.seconds ? ts.seconds*1000 : (typeof ts==="number" ? ts : 0)); }
  function fmtClock(ms){ const s=Math.max(0,Math.ceil(ms/1000)); const mm=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${mm}:${ss}`; }

  // Sorteo animaciÃ³n
  async function startDrawAnimation(order){
    const draw=document.getElementById("drawOverlay"); const slip=document.getElementById("slip"); const list=document.getElementById("orderList");
    list.innerHTML=""; draw.style.display="grid";
    const names=await Promise.all(order.map(uid=>nameOf(uid)));
    names.forEach((n,i)=>{ const item=document.createElement("div"); item.className="order-item"; item.innerHTML=`<div class="order-badge">${i+1}</div><div class="order-name" id="ord-${i}">â€”</div>`; list.appendChild(item); });
    for(let i=0;i<order.length;i++){ const n=names[i]; slip.textContent=n; slip.classList.remove("reveal"); void slip.offsetWidth; slip.classList.add("reveal"); await new Promise(r=>setTimeout(r,900)); const slot=document.getElementById(`ord-${i}`); if(slot) slot.textContent=n; await new Promise(r=>setTimeout(r,450)); }
    const roomSnap=await getDoc(roomRef); const roundId=String(roomSnap.data().round||0);
    if(isHost && roundId!=="0"){ await updateDoc(doc(db,"rooms",state.code,"rounds",roundId),{status:"prompt",promptStartedAt:serverTimestamp(),turnIndex:0}); }
    setTimeout(()=>{ draw.style.display="none"; },600);
  }

  // === RESULTADOS: computar votos, expulsar y mostrar ===
async function tallyVotes(roundId){
  // Lee votos
  const votesSnap = await getDocs(collection(db,"rooms",state.code,"rounds",String(roundId),"votes"));
  const counts = new Map(); // targetUid -> cantidad
  for (const d of votesSnap.docs){
    const v = d.data()?.target;
    if(!v) continue;
    counts.set(v, (counts.get(v)||0)+1);
  }
  if(counts.size===0) return { expelledUid:null, tie:false, counts:{} };

  // MayorÃ­a y manejo de empate
  let max = 0, winners = [];
  for (const [uid,c] of counts){
    if (c>max){ max=c; winners=[uid]; }
    else if (c===max){ winners.push(uid); }
  }
  const tie = winners.length!==1;
  const expelledUid = tie ? null : winners[0];

  // Devuelvo tambiÃ©n como objeto plano para guardar en Firestore
  const countsObj = {};
  for (const [k,v] of counts) countsObj[k]=v;
  return { expelledUid, tie, counts:countsObj, max };
}

async function getAssignment(uid){
  try{
    const a = await getDoc(doc(db,"rooms",state.code,"assignments",uid));
    return a.exists()? a.data() : null;
  }catch{ return null; }
}

function showResultsOverlayUI({ title, subtitle, color="#cfe4ff" }){
  const ov = document.getElementById("resultsOverlay");
  const box = document.getElementById("resultsBox");
  const sub = document.getElementById("resultsSub");
  box.innerHTML = `<div style="font-weight:900;font-size:clamp(20px,6.5vw,28px);color:${color}">${title}</div>`;
  sub.textContent = subtitle || "";
  ov.style.display = "grid";
}

function hideResultsOverlayUI(){ document.getElementById("resultsOverlay").style.display="none"; }

// Inicia una nueva ronda manteniendo roles y marcando vivos/muertos
async function startNextRoundKeepingRoles(){
  // Carga sala y settings actuales
  const roomSnap = await getDoc(roomRef);
  const room = roomSnap.data()||{};
  const st = room.settings || roomSettings || {};
  const tema = st.tema || state.temas[state.temaIndex];
  const timeSec = st.timeSec || state.tiempos[state.tiempoIndex];

  // Traigo asignaciones para ver quiÃ©n sigue vivo
  const asgSnap = await getDocs(collection(db,"rooms",state.code,"assignments"));
  const all = asgSnap.docs.map(d=>d.data());
  const alive = all.filter(p => p.alive!==false);

  // Si quedan 0 impostores o 0 civiles, podrÃ­as terminar partida (opcional)
  const vivosImpostor = alive.filter(p=>p.role==="IMPOSTOR").length;
  const vivosCivil    = alive.filter(p=>p.role!=="IMPOSTOR").length;

  // (Opcional) cond. de fin â€” por ahora seguimos siempre si hay al menos 3
  if (alive.length < 3){
    showResultsOverlayUI({
      title: "No hay suficientes jugadores vivos para continuar",
      subtitle: "VolvÃ© al lobby y creÃ¡ una nueva partida.",
      color:"#ffd166"
    });
    return;
  }

  // Nuevo orden y nueva palabra
  const order = shuffleInPlace(alive.map(p=>p.uid));
  const palabra = pickWord(tema);
  const nextRound = (room.round||0) + 1;

  const batch = writeBatch(db);
  // Actualizo doc de sala
  batch.update(roomRef,{ round: nextRound, status: "playing", startedAt: serverTimestamp(), settings:{...st, timeSec} });

  // Actualizo asignaciones (misma doc, nuevo round y palabra solo a civiles vivos)
  for (const p of all){
    const ref = doc(db,"rooms",state.code,"assignments",p.uid);
    // Mantener alive como viene; roles igual
    const word = (p.alive!==false && p.role!=="IMPOSTOR") ? palabra : null;
    batch.set(ref,{ ...p, round: nextRound, word, tema, // keep role & alive
      revealedAt:null, vote:null
    }, { merge:true });
  }

  // Creo doc de ronda
  const roundRef = doc(db,"rooms",state.code,"rounds",String(nextRound));
  batch.set(roundRef,{ status:"reveal", createdAt: serverTimestamp(), order, turnIndex:0, timeSec });

  await batch.commit();

  // Pasar a "draw" tras la animaciÃ³n de rol (10s como tu flow actual)
  setTimeout(async()=>{ try{ await updateDoc(roundRef,{ status:"draw", drawStartedAt: serverTimestamp() }); }catch{} }, 10000);
}


  // Estado de ronda
  let currentRound=0;
  let roundState=null;
  let drawPlayedForRound=0;

  let unsubscribeRoundHint=null;
  let unsubscribeChat=null;
  let unsubscribeFirstWords=null;
  let unsubscribeRoundPhase=null;

  // Turn banner
  let _turnBannerTimer=null;
  function showTurnBanner(name){
    const banner=document.getElementById("turnBanner");
    const who=document.getElementById("turnName");
    who.textContent=name||"alguien";
    banner.classList.remove("hide"); banner.classList.add("show"); banner.style.display="block";
    if(_turnBannerTimer) clearTimeout(_turnBannerTimer);
    _turnBannerTimer=setTimeout(()=>{ banner.classList.remove("show"); banner.classList.add("hide"); setTimeout(()=>{ banner.style.display="none"; },350); },2200);
  }

  // primeras palabras
  let firstWordsMap = new Set();
  function subscribeFirstWords(roundId){
    if(unsubscribeFirstWords) unsubscribeFirstWords();
    firstWordsMap = new Set();
    unsubscribeFirstWords = onSnapshot(
      collection(db,"rooms",state.code,"rounds",String(roundId),"firstWords"),
      snap=>{
        firstWordsMap = new Set(snap.docs.map(d=>d.id));
        advanceIfReadyByHost();
      }
    );
  }

  // host avanza turno / pasa a discuss cuando todos mandaron palabra
  async function advanceIfReadyByHost(){
    if(!isHost || !roundState || roundState.status!=="prompt") return;
    const order = roundState.order || [];
    const idx   = roundState.turnIndex ?? 0;
    const uidTurno = order[idx];
    if(!uidTurno) return;
    if(firstWordsMap.has(uidTurno)){
      const roundId = String(currentRound);
      const nextIdx = idx + 1;
      if(nextIdx < order.length){
        try{ await updateDoc(doc(db,"rooms",state.code,"rounds",roundId),{turnIndex:nextIdx}); }catch(e){ console.warn(e); }
      }else{
        const tSec = roundState?.timeSec || roomSettings?.timeSec || state.tiempos[state.tiempoIndex];
        try{ await updateDoc(doc(db,"rooms",state.code,"rounds",roundId),{status:"discuss",discussStartedAt:serverTimestamp(), timeSec: tSec}); }catch(e){ console.warn(e); }
      }
    }
  }

  // COUNTDOWN discuss y pase a votaciÃ³n (host)
  let discussTicker = null;
  function startDiscussCountdown(roundDocData, isHostNow){
    if(discussTicker) { clearInterval(discussTicker); discussTicker=null; }
    const startMs = toMillis(roundDocData?.discussStartedAt);
    const totalSec = roundDocData?.timeSec || roomSettings?.timeSec || state.tiempos[state.tiempoIndex];
    const totalMs = (totalSec||60)*1000;

    if(!startMs){ timerEl.textContent=""; return; }

    discussTicker = setInterval(async ()=>{
      const now = Date.now();
      const left = (startMs + totalMs) - now;
      timerEl.textContent = fmtClock(left);

      if(left <= 0){
        clearInterval(discussTicker); discussTicker=null;
        timerEl.textContent = "00:00";
        if(isHostNow){
          try{
            const roomSnap = await getDoc(roomRef);
            const roundId = String(roomSnap.data().round||0);
            await updateDoc(doc(db,"rooms",state.code,"rounds",roundId),{
              status:"vote",
              voteStartedAt: serverTimestamp()
            });
          }catch(e){ console.warn(e); }
        }
      }
    }, 250);
  }

  function subscribeChat(roundId){
    if(unsubscribeChat) unsubscribeChat();
    let lastByUid = new Map();

    unsubscribeChat = onSnapshot(
      collection(db,"rooms",state.code,"rounds",String(roundId),"chat"),
      async snap=>{
        const items = snap.docs
          .map(d=>({ _doc:d, id:d.id, ...d.data() }))
          .sort((a,b)=>(a.at?.seconds||0)-(b.at?.seconds||0));

        if(isHost && roundState?.status==="discuss"){
          for(const m of items){
            if(m.kind!=="chat") continue;
            const prev = lastByUid.get(m.uid)||0;
            const t = toMillis(m.at);
            if(prev && (t - prev) < 3000){
              try{ await deleteDoc(m._doc.ref); }catch(e){ console.warn("No pude borrar msg rÃ¡pido", e); }
              continue;
            }
            lastByUid.set(m.uid, t);
          }
        }

        ui.chatList.innerHTML = items.map(m=>{
          const mine = m.uid === (auth.currentUser && auth.currentUser.uid);
          return `<div class="chat-row ${mine?'mine':'other'}"><div class="bubble"><div class="name">${sanitize(m.name)||"Jugador"}</div><div class="text">${sanitize(m.text||"")}</div></div></div>`;
        }).join("");
        ui.chatList.scrollTop = ui.chatList.scrollHeight;
      }
    );
  }

  function subscribeRoundPhase(roundId){
    if (unsubscribeRoundPhase) unsubscribeRoundPhase();

    const rRef = doc(db,"rooms",state.code,"rounds",String(roundId));
    unsubscribeRoundPhase = onSnapshot(rRef, async (rdoc)=>{
      if(!rdoc.exists()) return;

      roundState = rdoc.data();
      const phase = roundState.status;
      const discussPanel = document.getElementById("phaseDiscuss");

      if(phase==="reveal"){
        discussPanel.style.display="none";
      }

      if(phase==="results"){
  // Mostrar panel principal (por si estaba oculto)
  document.getElementById("phaseDiscuss").style.display="block";
  ui.turnHint.textContent = "Resultados";
  timerEl.textContent = "";

  const rRef = doc(db,"rooms",state.code,"rounds",String(currentRound));
  const roundId = String(currentRound);

  // Solo el host computa una vez y guarda el resultado
  if(isHost && !roundState.resultsComputed){
    try{
      const { expelledUid, tie, counts } = await tallyVotes(roundId);

      // Guardar resultado en la ronda (para que todos lo lean)
      await updateDoc(rRef, {
        resultsComputed: true,
        expelledUid: expelledUid || null,
        tie: !!tie,
        counts
      });

      // Si hay expulsado, marcarlo como muerto
      if(expelledUid){
        await updateDoc(doc(db,"rooms",state.code,"assignments",expelledUid), { alive:false });
      }
    }catch(e){ console.warn("Error al computar resultados:", e); }
  }

  // Mostrar overlay a todos (se lee de los datos de la ronda)
  // dar un pequeÃ±o delay para asegurar que el host haya escrito los campos
  setTimeout(async ()=>{
    try{
      const rDoc = await getDoc(rRef);
      const rData = rDoc.data()||{};
      const tie = !!rData.tie;
      const expelledUid = rData.expelledUid || null;

      if(tie || !expelledUid){
        showResultsOverlayUI({
          title: "Empate â€” Nadie fue expulsado",
          subtitle: "Se jugarÃ¡ otra ronda con nueva palabra.",
          color: "#ffd166"
        });
      }else{
        const asg = await getAssignment(expelledUid);
        const nombre = asg?.name || "Jugador";
        const rol = asg?.role || "â€”";
        showResultsOverlayUI({
          title: `Eliminado: ${nombre}`,
          subtitle: `Rol: ${rol}`,
          color: rol==="IMPOSTOR" ? "#ff6b6b" : "#cfe4ff"
        });
      }
    }catch(e){ console.warn(e); }
  }, 250);

  // Tras unos segundos, ocultar overlay y arrancar siguiente ronda (host)
  setTimeout(async ()=>{
    hideResultsOverlayUI();
    if(isHost){
      try{ await startNextRoundKeepingRoles(); }catch(e){ console.warn(e); }
    }
  }, 6000);
}


      if(phase==="draw"){
        discussPanel.style.display="none";
        if(drawPlayedForRound!==roundId){
          drawPlayedForRound=roundId;
          startDrawAnimation(roundState.order||[]);
        }
      }

      if(phase==="prompt"){
        discussPanel.style.display="block";
        document.getElementById("firstWordTip").style.display="block";
        ui.chatInput.placeholder="Primero UNA palabra (2â€“24 letras)â€¦";
        const idx=roundState.turnIndex??0;
        const uidTurno=(roundState.order||[])[idx];
        ui.turnHint.textContent = uidTurno ? `Turno de: ${await nameOf(uidTurno)}` : "";
        timerEl.textContent = "";
      }

      if(phase==="discuss"){
        discussPanel.style.display="block";
        document.getElementById("firstWordTip").style.display="none";
        ui.turnHint.textContent="Chat libre";
        ui.chatInput.placeholder="DecÃ­ tu pista/suspecha (3s cooldown)";
        startDiscussCountdown(roundState, isHost);
      }

      if(phase==="vote"){
        discussPanel.style.display="block";
        ui.turnHint.textContent="VotaciÃ³n";
        timerEl.textContent = "";
        renderVoteBar();
      }
    });
  }

  // Detectar cambio de ronda desde rooms y enganchar suscripciones de la ronda
  onSnapshot(roomRef, async s=>{
    if(!s.exists()) return;
    const data = s.data();
    const newRound = data.round || 0;

    if(newRound && newRound !== currentRound){
      currentRound = newRound;
      subscribeChat(currentRound);
      subscribeFirstWords(currentRound);
      subscribeRoundPhase(currentRound);
    }else{
      currentRound = newRound;
    }
  });

  // Fallbacks de fase (host)
  onSnapshot(roomRef, async (snap)=>{
    if(!snap.exists()||!isHost) return;
    const data=snap.data(); const rId=data.round||0; if(!rId) return;
    const rRef=doc(db,"rooms",state.code,"rounds",String(rId)); const rDoc=await getDoc(rRef); if(!rDoc.exists()) return;
    const r=rDoc.data();
    const toMs=(ts)=>ts?.toMillis?.()??(ts?.seconds?ts.seconds*1000:(typeof ts==="number"?ts:0));
    const now=Date.now(), createdMs=toMs(r.createdAt), drawMs=toMs(r.drawStartedAt);
    if(r.status==="reveal" && createdMs && now-createdMs>11000) { try{ await updateDoc(rRef,{status:"draw",drawStartedAt:serverTimestamp()}); }catch{} }
    if(r.status==="draw" && drawMs && now-drawMs>20000) { try{ await updateDoc(rRef,{status:"prompt",promptStartedAt:serverTimestamp(),turnIndex:0}); }catch{} }
  });

  // UI chat
  const ui={
    chatForm:document.getElementById("chatForm"),
    chatInput:document.getElementById("chatInput"),
    chatList:document.getElementById("chatList"),
    voteBar:document.getElementById("voteBar"),
    cooldownHint:document.getElementById("cooldownHint"),
    turnHint:document.getElementById("turnHint"),
  };

  let cooldownUntil=0;
  function canSendNow(){
    const now=Date.now();
    if(roundState?.status==="prompt") return true;
    if(now<cooldownUntil){ const left=Math.ceil((cooldownUntil-now)/1000); ui.cooldownHint.textContent=`EsperÃ¡ ${left}s para volver a enviar`; return false; }
    ui.cooldownHint.textContent=""; return true;
  }

  function isOneWordLatin(str){ return /^\p{L}{2,24}$/u.test(str); }
  function showError(msg){
    ui.cooldownHint.textContent=msg; ui.cooldownHint.style.color="#ff7b7b";
    ui.chatInput.style.outline="2px solid #ff7b7b";
    setTimeout(()=>{ ui.cooldownHint.style.color=""; ui.chatInput.style.outline=""; },1800);
  }

  document.getElementById("chatForm").addEventListener("submit", async (e)=>{
    e.preventDefault();
    if(!roundState) { showError("No hay ronda activa."); return; }
    const raw=(ui.chatInput.value||"").trim(); if(!raw) return;

    const myUid=auth.currentUser?.uid;
    const roundId=String(currentRound);

    try{
      if(roundState.status==="prompt"){
        const idx=roundState.turnIndex??0; const order=roundState.order||[]; const uidTurno=order[idx];

        if(!myUid || !uidTurno || String(myUid)!==String(uidTurno)){
          const name = uidTurno ? await nameOf(uidTurno) : "alguien";
          showError(`EsperÃ¡ tu turno. Ahora: ${name}.`); return;
        }
        if(!isOneWordLatin(raw)){ showError("EnviÃ¡ UNA sola palabra (2â€“24 letras, sin espacios)."); return; }

        if(firstWordsMap.has(myUid)){ showError("Ya enviaste tu palabra. EsperÃ¡ que avance el turno."); return; }

        await setDoc(doc(db,"rooms",state.code,"rounds",roundId,"firstWords",myUid),{
          uid:myUid, name:getStoredName(), text:raw, at:serverTimestamp()
        });
        const msgRef=doc(collection(db,"rooms",state.code,"rounds",roundId,"chat"));
        await setDoc(msgRef,{ uid:myUid, name:getStoredName(), text:raw, at:serverTimestamp(), kind:"firstword" });
        ui.chatInput.value="";
        return;
      }

      if(roundState.status==="discuss"){
        if(!canSendNow()) return;
        const msgRef=doc(collection(db,"rooms",state.code,"rounds",roundId,"chat"));
        await setDoc(msgRef,{ uid:myUid, name:getStoredName(), text:raw, at:serverTimestamp(), kind:"chat" });
        ui.chatInput.value=""; cooldownUntil=Date.now()+3000; canSendNow(); return;
      }

      showError("No podÃ©s enviar ahora.");

    }catch(e){
      console.error(e);
      showError(`Error al enviar: ${e?.message||e}`);
    }
  });

  // VotaciÃ³n
  async function renderVoteBar(){
    const asgSnap=await getDocs(collection(db,"rooms",state.code,"assignments"));
    const players=asgSnap.docs.map(d=>d.data()).filter(p=>p.alive!==false);
    document.getElementById("voteBar").innerHTML = players.map(p=>{
      const src=(p.avatarKey && AVATAR_MAP[p.avatarKey])?AVATAR_MAP[p.avatarKey]:"";
      return `<button class="btn" data-vote="${p.uid}" style="display:flex;align-items:center;gap:8px;padding:8px 10px;border-radius:12px">
        <span style="width:28px;height:28px;border-radius:50%;overflow:hidden;display:inline-grid;place-items:center;background:#0a213b;border:1px solid rgba(128,180,255,.25)">${src?`<img src="${src}" style="width:100%;height:100%;object-fit:cover">`:"?"}</span>
        ${sanitize(p.name)||"Jugador"}</button>`;
    }).join("");
    document.querySelectorAll("[data-vote]").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const votedUid=btn.getAttribute("data-vote");
        const roomSnap=await getDoc(roomRef); const roundId=roomSnap.data().round||0;
        const myVoteRef=doc(db,"rooms",state.code,"rounds",String(roundId),"votes",auth.currentUser.uid);
        try{ await setDoc(myVoteRef,{ voter:auth.currentUser.uid, target:votedUid, at:serverTimestamp() }); document.querySelectorAll("[data-vote]").forEach(b=>b.style.opacity=".6"); btn.style.opacity="1"; }catch(e){ console.warn(e); }
      });
    });
  }

  // Cierre automÃ¡tico cuando todos votan (solo jugadores vivos)
onSnapshot(roomRef, async s=>{
  if(!s.exists()) return;
  const data=s.data(); const roundId=data.round||0;

  onSnapshot(collection(db,"rooms",state.code,"rounds",String(roundId),"votes"), async snap=>{
    // ids de quienes votaron (son los docs en /votes, con id = uid del voter)
    const voted = new Set(snap.docs.map(d=>d.id));

    // Solo cuentan los vivos
    const asgSnap = await getDocs(collection(db,"rooms",state.code,"assignments"));
    const aliveVoters = asgSnap.docs
      .map(d=>d.data())
      .filter(p=>p.alive!==false)
      .map(p=>p.uid)
      .filter(Boolean);

    // Si todos los vivos ya votaron, pasamos a resultados
    if(isHost && aliveVoters.length>0 && aliveVoters.every(id=>voted.has(id))){
      await updateDoc(doc(db,"rooms",state.code,"rounds",String(roundId)),{
        status:"results",
        resultsAt:serverTimestamp()
      });
    }
  });
});


  // Copiar / Compartir
  document.getElementById("copyBtn").addEventListener("click", async ()=>{ try{ await navigator.clipboard.writeText(state.code); }catch{} });
  document.getElementById("shareBtn").addEventListener("click", async ()=>{
    const joinUrl=`${location.origin}/ingresar.html?code=${state.code}`;
    if(navigator.share){ try{ await navigator.share({title:"Unite a mi sala", text:`CÃ³digo ${state.code}`, url:joinUrl}); }catch{} }
    else { try{ await navigator.clipboard.writeText(joinUrl); alert("Enlace copiado"); }catch{ alert(joinUrl); } }
  });
  </script>
</body>
</html
